# 第一章作业

## 作业一：三种排序

```c
#include <stdio.h>

void swap1(int m, int n)
{
	int temp = m;
	m = n;
	n = temp;
}

void swap2(int* m, int* n)
{
	int temp = *m;
	*m = *n;
	*n = temp;
}

void swap3(int& m, int& n)
{
	int temp = m;
	m = n;
	n = temp;
}

int main()
{
	int a = 5, b = 10;
	printf("swap1转换前：a=%d b=%d\n", a, b);
	swap1(a, b);
	printf("swap1转换后：a=%d b=%d\n\n", a, b);

	a = 5, b = 10;
	printf("swap2转换前：a=%d b=%d\n", a, b);
	swap2(&a, &b);
	printf("swap2转换后：a=%d b=%d\n\n", a, b);

	a = 5, b = 10;
	printf("swap3转换前：a=%d b=%d\n", a, b);
	swap3(a, b);
	printf("swap3转换后：a=%d b=%d\n\n", a, b);

	return 0;
}
```

## 作业二：三元组

设计实现抽象数据类型“三元组 （Triplet）” 。每个三元组由任意三个实数的序列构成，基本操作包括：创建一个三元组，取三元组的任意一个分量，置三元组的任意一个分量，求三元组的最大分量、最小分量，显示三元组，销毁三元组等。

要求：

1. 写出“三元组 （Triplet）”抽象数据类型的定义，即数据对象、数据关系、基本操作

2. 练习抽象数据类型的表示和实现。

> 方法1：用结构体封装需要定义的数据类型，如定义三元组ADT时，首先用结构体封装“三元组”的三个分量。并利用typedef对结构体重新命名。
>
> 方法2：用指针描述“三元组”，要求：动态分配内存。
>

3. 完成所有基本操作的C语言实现与调用，并写测试程序。

> 说明一下我这个作业吧，虽然`typedef int ElemType;`了，但其实默认都是用的int类型，里面也都是`printf(“%d”);`，但是现在还有别的事，也不想多改了。就先这样吧。

#### 方法一：结构体

```c
#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>
#include <stdlib.h>

typedef int ElemType;

// 定义三元组结构体
typedef struct {
    ElemType first;
    ElemType second;
    ElemType third;
} Triplet;

// 创建三元组
Triplet* createTriplet(ElemType first, ElemType second, ElemType third) {
    Triplet* triplet = (Triplet*)malloc(sizeof(Triplet));

    if (triplet == NULL) {
        printf("内存分配失败\n");
        exit(1);
    }

    triplet->first = first;
    triplet->second = second;
    triplet->third = third;

    return triplet;
}

// 取三元组的任意一个分量
ElemType getTriplet(Triplet* triplet, int index) {

    switch (index) {
    case 1:
        return triplet->first;
    case 2:
        return triplet->second;
    case 3:
        return triplet->third;
    default:
        printf("无效的索引\n");
        exit(1);
    }
}

// 设置三元组的任意一个分量
void setTriplet(Triplet* triplet, int index, ElemType value) {
    switch (index) {
    case 1:
        triplet->first = value;
        break;
    case 2:
        triplet->second = value;
        break;
    case 3:
        triplet->third = value;
        break;
    default:
        printf("无效的索引\n");
        exit(1);
    }
}

// 求三元组的最大分量
ElemType maxTriplet(Triplet* triplet) {
    ElemType max = triplet->first;
    if (triplet->second > max)
        max = triplet->second;
    if (triplet->third > max)
        max = triplet->third;
    return max;
}

// 求三元组的最小分量
ElemType minTriplet(Triplet* triplet) {
    ElemType min = triplet->first;
    if (triplet->second < min)
        min = triplet->second;
    if (triplet->third < min)
        min = triplet->third;
    return min;
}

// 是否升序
int isAscending(Triplet* Trip) {

    return(Trip->first <= Trip->second && Trip->second <= Trip->third);
}

// 是否降序
int isDscending(Triplet* Trip) {

    return(Trip->first >= Trip->second && Trip->second >= Trip->third);
}

// 显示三元组
void displayTriplet(Triplet* triplet) {
    printf("(%d, %d, %d)\n", triplet->first, triplet->second, triplet->third);
}

// 销毁三元组
void destroyTriplet(Triplet* triplet) {
    free(triplet);
}

int main() {
    printf("初始化三元组: （请输入三个值）：");
    ElemType a, b, c;
    scanf("%d %d %d", &a, &b, &c);
    Triplet* myTriplet = createTriplet(a, b, c);

    if (isAscending(myTriplet)) {
        printf("该三元组元素为升序\n");
    }
    if (isDscending(myTriplet)) {
        printf("该三元组元素为降序\n");
    }

    printf("打印三元组: ");
    displayTriplet(myTriplet);

    printf("请输入要查看的索引号：");
    int index;
    scanf("%d", &index);
    printf("对应的值是: %d\n", getTriplet(myTriplet, index));

    printf("请输入要修改的索引号，以及值：");
    ElemType modify;
    scanf("%d %d", &index, &modify);
    setTriplet(myTriplet, index, modify);
    printf("修改成功");
    displayTriplet(myTriplet);

    printf("三元组最大值是: %d\n", maxTriplet(myTriplet));
    printf("三元组最小值是: %d\n", minTriplet(myTriplet));

    destroyTriplet(myTriplet);

    return 0;
}
```



#### 方法二：

```c
#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>
#include <stdlib.h>

typedef int ElemType;

// 定义三元组结构体
typedef struct {
    ElemType* elem;
} Triplet;

// 创建三元组
Triplet* createTriplet(ElemType first, ElemType second, ElemType third) {

    Triplet* triplet = (Triplet*)malloc(sizeof(Triplet));
    if (triplet == NULL) {
        printf("内存分配失败\n");
        exit(1);
    }

    triplet->elem = (ElemType*)malloc(4 * sizeof(ElemType));
    if (triplet->elem == NULL) {
        printf("内存分配失败\n");
        exit(1);
    }

    triplet->elem[0] = first;
    triplet->elem[1] = second;
    triplet->elem[2] = third;

    return triplet;
}

// 取三元组的任意一个分量
ElemType getTriplet(Triplet* triplet, int index) {
    if (index < 1 || index > 3) {
        printf("无效的索引\n");
        exit(1);
    }

    return triplet->elem[index - 1];
}

// 置三元组的任意一个分量
void setTriplet(Triplet* triplet, int index, ElemType value) {
    if (index < 1 || index > 3) {
        printf("无效的索引\n");
        exit(1);
    }

    triplet->elem[index - 1] = value;
}

// 求三元组的最大分量
ElemType maxTriplet(Triplet* triplet) {
    ElemType max = triplet->elem[0];

    for (int i = 1; i < 3; ++i) {
        if (triplet->elem[i] > max)
            max = triplet->elem[i];
    }

    return max;
}

// 求三元组的最小分量
ElemType minTriplet(Triplet* triplet) {

    ElemType min = triplet->elem[0];
    for (int i = 1; i < 3; ++i) {
        if (triplet->elem[i] < min)
            min = triplet->elem[i];
    }

    return min;
}

// 是否升序
int isAscending(Triplet* Trip) {

    return(Trip->elem[1] <= Trip->elem[2] && Trip->elem[2] <= Trip->elem[3]);
}

// 是否降序
int isDscending(Triplet* Trip) {

    return(Trip->elem[1] >= Trip->elem[2] && Trip->elem[2] >= Trip->elem[3]);
}

// 显示三元组
void displayTriplet(Triplet* triplet) {
    printf("(%d, %d, %d)\n", triplet->elem[0], triplet->elem[1], triplet->elem[2]);
}

// 销毁三元组
void destroyTriplet(Triplet* triplet) {
    free(triplet->elem);
    free(triplet);
}

int main() {
    printf("初始化三元组: （请输入三个值）：");
    ElemType a, b, c;
    scanf("%d %d %d", &a, &b, &c);
    Triplet* myTriplet = createTriplet(a, b, c);

    printf("打印三元组: ");
    displayTriplet(myTriplet);

    if (isAscending(myTriplet)) {
        printf("该三元组元素为升序\n");
    }
    if (isDscending(myTriplet)) {
        printf("该三元组元素为降序\n");
    }

    printf("请输入要查看的索引号：");
    int index;
    scanf("%d", &index);
    printf("对应的值是: %d\n", getTriplet(myTriplet, index));

    printf("请输入要修改的索引号，以及值：");
    ElemType modify;
    scanf("%d %d", &index, &modify);
    setTriplet(myTriplet, index, modify);
    printf("修改成功");
    displayTriplet(myTriplet);

    printf("三元组最大值是: %d\n", maxTriplet(myTriplet));
    printf("三元组最小值是: %d\n", minTriplet(myTriplet));

    destroyTriplet(myTriplet);

    return 0;
}
```



### ……别看我……

```c
#include <stdio.h>

#define OK 1
#define ERROR 0

typedef int ElemType;

typedef struct { //三元组的类型定义
	ElemType e[3];
}Triplet;

void initTriplet(Triplet& T, int a, int b, int c) { //三元组的初始化
	T.e[0] = a;
	T.e[1] = b;
	T.e[2] = c;
}

int getELem(Triplet& T, ElemType i, ElemType e) {
	if (i < 1 || i>3)
		return ERROR;
	else e = T.e[i - 1];
	return OK;
}

int isAscending(Triplet T) {

	return(T.e[0] <= T.e[1] && T.e[1] <= T.e[2]);
}

int isDscending(Triplet T) {

	return(T.e[0] >= T.e[1] && T.e[1] >= T.e[2]);
}

int getMAX(Triplet T) {
	int temp;

	if (T.e[0] > T.e[1])
		temp = T.e[0];
	else
		temp = T.e[1];
	if (T.e[2] > temp)
		temp = T.e[2];
	return temp;
}

int getMIN(Triplet T) {
	int temp;

	if (T.e[0] > T.e[1])
		temp = T.e[1];
	else
		temp = T.e[0];
	if (T.e[2] < temp)
		temp = T.e[2];
	return temp;
}

int main() {

	Triplet T;
	ElemType a, b, c, e, i;

	printf("请输入三个整数\n");
	scanf_s("%d %d %d", &a, &b, &c);
	initTriplet(T, a, b, c);
	printf("调用初始化后，T的三个值为%d %d %d\n", T.e[0], T.e[1], T.e[2]);

	printf("请输入要获取数据的位置\n");
	getELem(T, i, e);
	printf("第%d位的元素是%d\n", i, e);

	if (isAscending(T)) {
		printf("该三元组元素为升序\n");
	}
	if (isDscending(T)) {
		printf("该三元组元素为降序\n");
	}

	printf("该三元组中的最大值是 %d\n", getMAX(T));
	printf("该三元组中的最小值是 %d\n", getMIN(T));

	return 0;
}
```

