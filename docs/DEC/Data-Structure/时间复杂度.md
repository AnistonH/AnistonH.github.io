# 时间复杂度例题

## 1

```c
int main() {
	int i, j, k;
	int n;
	int x;
	for (i = 1; i <= n; i++) {
		for (j = 1; j <= i; j++) {
			for (k = 1; k <= j; k++) {
				x = x + 1;
			}
		}
	}
	printf("\n%d\n", x);
	return 0;
}
```

这段函数的时间复杂度是O(n^3)。

让我们逐步分析：

1. 外层循环：`for (i = 1; i <= n; i++)`，循环次数为n次。

2. 第二层循环：`for (j = 1; j <= i; j++)`，循环次数从1到n不等，平均循环次数约为n/2次。

3. 第三层循环：`for (k = 1; k <= j; k++)`，循环次数从1到i不等，平均循环次数约为i/2次。

因此，总的循环次数可以近似为：

`1 + 2 + 3 + ... + n/2 ≈ (n/2)^2 = n^2/4`

所以，时间复杂度为O(n^2/4) = O(n^2)。

然而，我们还需要考虑内部的赋值操作 `x = x + 1;`。这个操作在最内层循环中执行，而最内层循环的次数等于第二层循环的次数乘以第三层循环的次数，即`(i/2) * (i/2) = i^2/4`。

因此，总的赋值操作次数可以近似为：

`1^2/4 + 2^2/4 + 3^2/4 + ... + n^2/4 ≈ (1/4) * (1^2 + 2^2 + 3^2 + ... + n^2)`

这个求和结果是一个平方和的形式，根据平方和的求和公式，可以得到：

`(1/4) * (1^2 + 2^2 + 3^2 + ... + n^2) = (1/4) * (n * (n+1) * (2n+1)) / 6`

因此，赋值操作的时间复杂度可以近似为O(n^3)。

综合考虑循环次数和赋值操作次数，最终的时间复杂度为O(n^3)。



## 2

```c
int main() {
	int i = 1;
	int n;
	while (i <= n) {
		i = i * 2;
	}
	return 0;
}
```

这段函数的时间复杂度是 O(log n)。

让我们逐步分析：

1. 初始化变量：`int i = 1;` 这是一个常数时间操作，与输入规模 n 无关。

2. 循环条件：`while (i <= n)`，循环会一直执行直到 i 大于 n。

3. 循环体内操作：`i = i * 2;` 这个操作将 i 乘以 2，即使每次循环 i 的值都会翻倍。

根据上述分析，循环体内的操作会导致 i 的值以指数形式增长，即 i 的取值序列为 1, 2, 4, 8, 16, ...，直到 i 大于 n。

因此，循环的迭代次数取决于 i 能够增长到多少才能超过 n。假设最后一次循环时 i 的值为 m，则满足以下条件：

`2^m > n`

> 若循环执行1次：i = 1 x 2 = 2
>
> 若循环执行2次：i = 2 x 2 = 2^2^
>
> 若循环执行3次：i = 2^2^ x 2 = 2^3^
>
> 若循环执行 m 次：i = 2^m^

要求：`i<=m`，即 2^m^ <= n，

即`m >= log2(n)`

因此，迭代次数 m 的上限为 log2(n)。由于每次迭代都会将 i 值翻倍，因此迭代次数 m 的上限也表示 i 的最大值。

综上所述，该函数的时间复杂度为 O(log n)。